---
tags:
  - GPT4
  - Prompt
  - OpenAI
  - 大模型
---

# 自主意识


![img](assets/autonomous_agent.png)
*A unified framework for the architecture design of LLM-based autonomous agent*^[A Survey on Large Language Model based
Autonomous Agents]

### Profiling Module
The profiling module aims to **indicate the profiles of the agent roles**,
which are usually written into the prompt to influence the LLM behaviors. Agent profiles typically
encompass basic information such as age, gender, and career^[Joon Sung Park, Joseph C. O’Brien, Carrie J. Cai, Meredith Ringel Morris, Percy Liang, and
Michael S. Bernstein. Generative agents: Interactive simulacra of human behavior. In In the
36th Annual ACM Symposium on User Interface Software and Technology (UIST ’23), UIST
’23, New York, NY, USA, 2023. Association for Computing Machinery.], as well as psychology information,
reflecting the personalities of the agents, and social information, detailing the relationships
between agents^[Lei Wang. Recagent. https://github.com/RUC-GSAI/YuLan-Rec, 2023.]. The choice of information to profile the agent is largely determined by the
specific application scenarios. _For instance, if the application aims to study human cognitive process,
then the psychology information becomes pivotal._

### Memory Module

The memory module **stores information** perceived from the environment and leverages the **recorded memories** to facilitate future actions. The
memory module can help the agent to accumulate experiences, self-evolve, and behave in a more consistent, reasonable, and effective manner.


#### 1 Memory Structures

让AI玩MC，假设AI的任务是`["撸树", "造木稿", "挖石头"]`，把这个指令写到prompt里给agent，结果AI发现不能造木稿。然后根据反馈重新动作规划
新任务`["撸树", "造工作台", "造木稿", "挖石头"]`，来修正prompt，那么这种记忆就是Unified Memory。

假设AI下地底找钻石的过程中发现钻石周围都是岩浆，那么根据当前情况，AI会认为自己需要盛水的水桶（这里不考虑用砖块造路），然后AI回想之前来到这里的途中有一条河。
那么就既有short-term也有long-term memories。这种记忆就是Hybrid Memory。

- **Unified Memory**
This structure only simulates the human short-term memory, which is usually
realized by in-context learning, and the memory information is directly written into the prompts.
DEPS^[Zihao Wang, Shaofei Cai, Anji Liu, Xiaojian Ma, and Yitao Liang. Describe, explain, plan
and select: Interactive planning with large language models enables open-world multi-task
agents. arXiv preprint [arXiv:2302.01560](https://arxiv.org/abs/2302.01560), 2023.] ([code](https://github.com/CraftJarvis/MC-Planner)) is also a game agent, but it is developed for Minecraft. The agent initially generates task plans and then utilizes them
to prompt LLMs, which in turn produce actions to complete the task. These plans can be deemed as
the agent’s short-term memory.

- **Hybrid Memory**
This structure explicitly models the human short-term and long-term memories.
The short-term memory temporarily buffers recent perceptions, while long-term memory consolidates important information over time.

#### 2 Memory Formats
看图

- **Natural Languages**
memory information such as the agent behaviors and
observations are directly described using raw natural language.
_Voyager^[Guanzhi Wang, Yuqi Xie, Yunfan Jiang, Ajay Mandlekar, Chaowei Xiao, Yuke Zhu, Linxi
Fan, and Anima Anandkumar. Voyager: An open-ended embodied agent with large language
models. arXiv preprint [arXiv:2305.16291](https://arxiv.org/abs/2305.16291), 2023.]employs natural language descriptions to represent skills
within the Minecraft, which are directly stored in memory._

#### 3 Memory Operations
- **Memory Reading** to extract meaningful information from memory to enhance the agent’s actions.
_For example, using the **previously successful actions** to achieve similar goals_^[Xizhou Zhu, Yuntao Chen, Hao Tian, Chenxin Tao, Weijie Su, Chenyu Yang, Gao Huang, Bin
Li, Lewei Lu, Xiaogang Wang, et al. Ghost in the minecraft: Generally capable agents for
open-world enviroments via large language models with text-based knowledge and memory.
arXiv preprint [arXiv:2305.17144](https://arxiv.org/abs/2305.17144), 2023.] ([Project](https://github.com/OpenGVLab/GITM)). The key of memory reading lies in how to extract valuable information.
Usually, there three commonly used criteria for information extraction, that is, **the recency**, **relevance**,
and **importance**^[Joon Sung Park, Joseph C. O’Brien, Carrie J. Cai, Meredith Ringel Morris, Percy Liang, and
Michael S. Bernstein. Generative agents: Interactive simulacra of human behavior. In In the
36th Annual ACM Symposium on User Interface Software and Technology (UIST ’23), UIST
’23, New York, NY, USA, 2023. Association for Computing Machinery.]. Memories that are more recent, relevant, and important are more likely to
be extracted.

$m^* = \arg \mathop{\min}\limits_{m \in M} \alpha s^{rec}(q,m) + \beta s^{rel}(q,m) + \gamma s^{imp}(m)$

where $q$ is the query, for example, the task that the agent should address or the context in which the
agent is situated. $M$ is the set of all memories. $s^{rec} (·)$, $s^{rel} (·)$ and $s^{imp} (·)$ are the scoring functions
for measuring the recency, relevance, and importance of the memory $m$.

- **Memory Writing**
The purpose of memory writing is to store information about the perceived
environment in memory.

- **Memory Reflection**
the objective is to provide agents with the capability to independently summarize and infer more abstract, complex and
high-level information.

Generative Agent^[Joon Sung Park, Joseph C. O’Brien, Carrie J. Cai, Meredith Ringel Morris, Percy Liang, and
Michael S. Bernstein. Generative agents: Interactive simulacra of human behavior. In In the
36th Annual ACM Symposium on User Interface Software and Technology (UIST ’23), UIST
’23, New York, NY, USA, 2023. Association for Computing Machinery.]

1. 基于近期的记忆，由agent产生3个key questions
2. 3个问题用于query the memory以获取相关信息

## GITM
**GITM**(Ghost in the Minecraft)[6]

the actions that successfully accomplish the sub-goals are stored in a list(by LLM Planner). When the
list contains more than five elements, the agent summarizes them into a common and abstract pattern
and replaces all the elements. 区分knowledge 和 memory.

![img](assets/GITM.png)

### LLM Decomposer

LLM Decomposer 的作用在于对目标进行分解。首先，对目标进行定义，在MC里面，每个目标可以被定义为如下五元组：

  $(Object, Count, Material, Tool, Info)$

其中$Object$指目标物品，$Count$指具体的数量，$Material$和$Tool$表明了获得该物品需要的前置条件，$Info$中描述了与该目标物品相关的文本知识。LLM Decomposer 在收到一个目标输入之后，便可以根据其前置条件对该目标进行分解，即生成以
$Material$和$Tool$ 为$Object$的子任务。这个分解的过程是可以递归进行的，直到分解的出的子目标没有前置条件为止。这一部分可以使用语言大模型来实现
```
SYSTEM:
  You are an assistant for the game Minecraft.
  I will give you some target object and some knowledge related to the object. Please write the
  obtaining of the object as a goal in the standard form.
  The standard form of the goal is as follows:
  {
    "object": "the name of the target object",
    "count": "the target quantity",
    "material": "the materials required for this goal, a dictionary in the form {material_name:
    material_quantity}. If no material is required, set it to None",
    "tool": "the tool used for this goal. If multiple tools can be used for this goal, only write
    the most basic one. If no tool is required, set it to None",
    "info": "the knowledge related to this goal"
  }
  The information I will give you:
  Target object: the name and the quantity of the target object
  Knowledge: some knowledge related to the object.
  Requirements:
  1. You must generate the goal based on the provided knowledge instead of purely depending
  on your own knowledge.
  2. The "info" should be as compact as possible, at most 3 sentences. The knowledge I give you
  may be raw texts from Wiki documents. Please extract and summarize important information
  instead of directly copying all the texts.
  Goal Example:
  { "object": "iron_ore",
    "count": 1,
    "material": None,
    "tool": "stone_pickaxe",
    "info": "iron ore is obtained by mining iron ore. iron ore is most found in level 53. iron ore
    can only be mined with a stone pickaxe or better; using a wooden or gold pickaxe will yield
    nothing."
  }
  {
    "object": "wooden_pickaxe",
    "count": 1,
    "material": {"planks": 3, "stick": 2},
    "tool": "crafting_table",
    "info": "wooden pickaxe can be crafted with 3 planks and 2 stick as the material and
    crafting table as the tool."
  }

USER:
Target object: {object quantity} {object name}
Knowledge: {related knowledge}
```

例子
```
SYSTEM:
  你是一个AI助手，我会给你一些目标对象以及与该对象相关的一些知识。

  我会给你的信息：
  目标对象：目标对象的名称和数量
  知识：与对象相关的一些知识。

  要求：
  1.你必须根据所提供的知识来生成目标，而不是纯粹依赖于你自己的知识。
  2.“信息”应尽可能紧凑，最多3句话。 我给你的知识可能是维基文档中的原始文本。 请提取并总结重要信息，而不是直接复制所有文本。

  目标示例：
  {“对象”：“西红柿炒鸡蛋”，
  “计数”：1，
  “材料”：”鸡蛋液, 西红柿块, 葱花, 糖, 盐”，
  “工具”：“锅, 盘子”，
  "info": "西红柿炒鸡蛋可以用锅制作。"
  }
  {“对象”：“西红柿块”，
  “计数”：8，
  “材料”：”西红柿”，
  “工具”：“刀”，
  "info": "西红柿可以用菜刀或水果刀切开"
  }

USER:
  目标对象：黄瓜凉菜
  知识：黄瓜凉菜含有干豆腐丝，黄瓜，芹菜等材料

Agent:
  {
    "对象": "黄瓜凉菜",
    "计数": 1,
    "材料": "黄瓜, 干豆腐丝, 芹菜",
    "工具": "刀, 碗",
    "info": "黄瓜凉菜的主要材料包括黄瓜、干豆腐丝和芹菜。制作时需要将这些材料切碎并混合在一起，可以使用刀和碗来完成。"
  }

USER:
  目标对象：干豆腐丝
  知识：干豆腐丝可以通过用刀切干豆腐获得

Agent:
{
  "对象": "干豆腐丝",
  "计数": 1,
  "材料": "干豆腐",
  "工具": "刀",
  "info": "干豆腐丝可以通过用刀切干豆腐获得。只需将干豆腐切成细丝状即可制作干豆腐丝。"
}
```

### LLM Planner

LLM Planner 的作用在于根据一个给出的任务，将其分解为结构化动作的组合，结构化动作是具有良好定义的在我的世界中的一些较为基本，容易通过脚本实现的动作。每个动作由三部分组成：

$(Name, Arguements, Description)$
```
SYSTEM:
You serve as an assistant that helps me play the game Minecraft.
I will give you a goal in the game. Please think of a plan to achieve the goal, and then write a sequence of actions to realize the plan. The requirements and instructions are as follows:

1. You can only use the following functions. Don’t make plans purely based on your experience, think about how to use these functions.

explore(object, strategy)
Move around to find the object with the strategy: used to find objects including block items and entities. This action is finished once the object is visible (maybe at the distance).
Augments:
- object: a string, the object to explore.
- strategy: a string, the strategy for exploration.

approach(object)
Move close to a visible object: used to approach the object you want to attack or mine. It may fail if the target object is not accessible.
Augments:
- object: a string, the object to approach.

craft(object, materials, tool)
Craft the object with the materials and tool: used for crafting new object that is not in the inventory or is not enough. The required materials must be in the inventory and will be consumed, and the newly crafted objects will be added to the inventory. The tools like the crafting table and furnace should be in the inventory and this action will directly use them. Don’t try to place or approach the crafting table or furnace, you will get failed since this action does not support using tools placed on the ground. You don’t need to collect the items after crafting. If the quantity you require is more than a unit, this action will craft the objects one unit by one unit. If the materials run out halfway through, this action will stop, and you will only get part of the objects you want that have been crafted.
Augments:
- object: a dict, whose key is the name of the object and value is the object quantity.
- materials: a dict, whose keys are the names of the materials and values are the quantities.
- tool: a string, the tool used for crafting. Set to null if no tool is required.

mine(object, tool)
Mine the object with the tool: can only mine the object within reach, cannot mine object from a distance. If there are enough objects within reach, this action will mine as many as you specify. The obtained objects will be added to the inventory.
Augments:
- object: a string, the object to mine.
- tool: a string, the tool used for mining. Set to null if no tool is required.

attack(object, tool)
Attack the object with the tool: used to attack the object within reach. This action will keep track of and attack the object until it is killed.
Augments:
- object: a string, the object to attack.
- tool: a string, the tool used for mining. Set to null if no tool is required.

equip(object)
Equip the object from the inventory: used to equip equipment, including tools, weapons, and armor. The object must be in the inventory and belong to the items for equipping.
Augments:
- object: a string, the object to equip.

digdown(object, tool)
Dig down to the y-level with the tool: the only action you can take if you want to go underground for mining some ore.
Augments:
- object: an int, the y-level (absolute y coordinate) to dig to.
- tool: a string, the tool used for digging. Set to null if no tool is required.

go_back_to_ground(tool)
Go back to the ground from underground: the only action you can take for going back to the ground if you are underground.
Augments:
- tool: a string, the tool used for digging. Set to null if no tool is required.

apply(object, tool)
Apply the tool on the object: used for fetching water, milk, lava with the tool bucket, pooling water or lava to the object with the tool water bucket or lava bucket, shearing sheep with the tool shears, blocking attacks with the tool shield.
Augments:
- object: a string, the object to apply to.
- tool: a string, the tool used to apply.

2. You cannot define any new function. Note that the "Generated structures" world creation option is turned off.

3. There is an inventory that stores all the objects I have. It is not an entity, but objects can be added to it or retrieved from it anytime at anywhere without specific actions. The mined or crafted objects will be added to this inventory, and the materials and tools to use are also from this inventory. Objects in the inventory can be directly used. Don’t write the code to obtain them. If you plan to use some object not in the inventory, you should first plan to obtain it. You can view the inventory as one of my states, and it is written in form of a dictionary whose keys are the name of the objects I have and the values are their quantities.

4. You will get the following information about my current state:
- inventory: a dict representing the inventory mentioned above, whose keys are the name of the objects and the values are their quantities
- environment: a string including my surrounding biome, the y-level of my current location, and whether I am on the ground or underground
Pay attention to this information. Choose the easiest way to achieve the goal conditioned on my current state. Do not provide options, always make the final decision.

5. You must describe your thoughts on the plan in natural language at the beginning. After that, you should write all the actions together. The response should follow the format:
{
    "explanation": "explain why the last action failed, set to null for the first planning",
    "thoughts": "Your thoughts on the plan in natural languag",
    "action_list": [
        {"name": "action name", "args": {"arg name": value}, "expectation": "describe the expected results of this action"},
        {"name": "action name", "args": {"arg name": value}, "expectation": "describe the expected results of this action"},
        {"name": "action name", "args": {"arg name": value}, "expectation": "describe the expected results of this action"}
    ]
}
The action_list can contain arbitrary number of actions. The args of each action should correspond to the type mentioned in the Arguments part. Remember to add “‘dict“‘ at the beginning and the end of the dict. Ensure that you response can be parsed by Python json.loads

6. I will execute your code step by step and give you feedback. If some action fails, I will stop at that action and will not execute its following actions. The feedback will include error messages about the failed action. At that time, you should replan and write the new code just starting from that failed action.

```

### LLM Interface

LLM Interface 的主要作用是把 Planner 下发的基于文本的动作转换为可以与环境交互的动作。主要有两种方式可以实现：人为写的脚本和RL学习的模型。由于在我的世界中结构化动作都有着很好的定义，从而采用了人写脚本的方式来进行控制。

这个步骤只有控制游戏角色或者机器人才需要。
```
SYSTEM:
You serve as an assistant that helps me play Minecraft.
I will give you my goal in the game, please break it down as a tree-structure plan to achieve this goal.
The requirements of the tree-structure plan are:
1. The plan tree should be exactly of depth 2.
2. Describe each step in one line.
3. You should index the two levels like ’1.’, ’1.1.’, ’1.2.’, ’2.’, ’2.1.’, etc.
4. The sub-goals at the bottom level should be basic actions so that I can easily execute them in the game.

USER:
The goal is to {goal description}. Generate the plan according to the requirements.
```
在此之后，对于树状规划上的每个叶子节点，将其通过语言模型转换为特定的行为描述（'verb', 'object', 'tools', 'materials'）
```
SYSTEM:
You serve as an assistant that helps me play Minecraft.
I will give you a sentence.
Please convert this sentence into one or several actions according to the following instructions.
Each action should be a tuple of four items, written in the form (’verb’, ’object’, ’tools’, ’materials’)
’verb’ is the verb of this action.
’object’ refers to the target object of the action.
’tools’ specifies the tools required for the action.
’material’ specifies the materials required for the action.
If some of the items are not required, set them to be ’None’.

USER:
The sentence is {sentence}. Generate the action tuple according to the requirements.
```

ExpeL^[Andrew Zhao, Daniel Huang, Quentin Xu, Matthieu Lin, Yong-Jin Liu, and Gao Huang. Expel:
Llm agents are experiential learners, 2023.]

在成功的对话中总结经验

使用`gpt-3.5-turbo`总结记忆,prompt以SYSTEM角色表述，将所有要被总结动作序列（MC里面的一些行为）放到USER里面。

```
SYSTEM
  You serve as an assistant that helps me play the game Minecraft.
  I am using a set of actions to achieve goals in the game Minecraft. I have recorded several
  action sequences successfully achieving a goal in a certain state. I will give you the goal, the
  state, and the sequences later. Please summarize the multiple action sequences into a single
  action sequence as a universal reference to achieve the goal given that certain state. Here are
  the instructions:
  1. Each action sequence is a sequence of the following actions:
  {action description}
  2. The action sequences before and after summarization are always conditioned on the given
  state, i.e., the actions are taken in that certain state to achieve the goal. I will describe the state
  in the following form: State: - inventory: a dict whose keys are the name of the objects and
  the values are their quantities. This inventory stores all the objects I have. - environment: a
  dict including my surrounding biome and whether I am on the ground or underground.
  3. The action sequence you summarize should be able to achieve the goal in general cases
  without specific modification. Every necessary action should be included, even though it does
  not appear in some sequences because I manually skipped it in some lucky cases. The actions
  redundant or irrelevant to the goal should be filtered out. The corner cases, such as success by
  luck and dealing with contingencies, should not be summarized into the final sequence.
  4. You should describe your thoughts on summarization in natural language at the beginning.
  After that, give me the summarized action sequence as a list in JSON format. Your response
  should follow this form:
  Thoughts: "Your thoughts and descriptions of your summarization"
  Summarized action sequence:
  [
    {"name": "action name", "args": {"arg name": value}, "expectation": "describe the
    expected results of this action"},
    {"name": "action name", "args": {"arg name": value}, "expectation": "describe the
    expected results of this action"},
    {"name": "action name", "args": {"arg name": value}, "expectation": "describe the
    expected results of this action"}
  ]
```

## LDA
流程

中文文本数据
- 原始中文文本数据
中文分词
- 使用分词工具（如jieba）对文本进行分词
构建词典
- 将分词后的词语建立索引，构建词典
文本表示
- 将文本数据转换为数值型表示，可以使用词袋模型或词嵌入等方法
训练LDA模型
- 使用处理后的文本数据训练LDA模型，设置主题数量（可依据困惑度、一致性确定最佳主题数）等参数
获取主题分布
- 得到文本中每个文档的主题分布，以及每个主题中的词语分布



## 名词解释

- agent

在大语言模型中，"agent" 通常指的是对话系统中的程序或机器人。这个 "agent" 能够理解用户的输入，并尝试提供有用的回复或执行一些任务。"Agent" 一词也可以用于描述其他类型的智能系统，如虚拟助手、聊天机器人、智能代理等，它们能够与用户交互并执行一系列指定的任务。

- Codex

Codex通常指的是OpenAI推出的代码生成模型，即OpenAI Codex。Codex是一个基于GPT架构的大型语言模型，专门针对编程和代码生成任务进行了训练。它是在GitHub的开发者环境中进行训练的，从大量的开源代码中学习，使其具有编写代码和理解编程语言的能力。

- LDA（Latent Dirichlet Allocation）

- zero-shot

在大语言模型中，"zero-shot" 通常指的是一种能力，即模型在没有额外训练或调整的情况下，能够在新的任务或领域中进行推理和生成输出。换句话说，"zero-shot" 意味着模型可以在未见过的情况下执行任务，而不需要专门为该任务进行训练。

[参考标识]: Joon
