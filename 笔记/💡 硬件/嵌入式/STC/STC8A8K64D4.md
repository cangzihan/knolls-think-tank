
# STC8A8K64D4

## 简介

STC8A8K64D4 系列单片机是不需要外部晶振和外部复位的单片机，是以超强抗干扰/超低价/高速/
低功耗为目标的 8051 单片机，在相同的工作频率下，STC8A8K64D4 系列单片机比传统的 8051 约快 12
倍（速度快 11.2~13.2 倍），依次按顺序执行完全部的 111 条指令，STC8A8K64D4 系列单片机仅需 147
个时钟，而传统 8051 则需要 1944 个时钟。STC8A8K64D4 系列单片机是 STC 生产的单时钟/机器周期(1T)
的单片机，是宽电压/高速/高可靠/低功耗/强抗静电/较强抗干扰的新一代 8051 单片机，超级加密。指令
代码完全兼容传统 8051。

## 特性
### Flash 存储器
- 最大 64K 字节 FLASH 程序存储器（ROM），用于存储用户代码
- 支持用户配置 EEPROM 大小，512 字节单页擦除，擦写次数可达 10 万次以上
- 支持在系统编程方式（ISP）更新用户应用程序，无需专用编程器
- 支持单芯片仿真，无需专用仿真器，理论断点个数无限制

### SRAM
- 128 字节内部直接访问 RAM（DATA）
- 128 字节内部间接访问 RAM（IDATA）
- 8192 字节内部扩展 RAM（内部 XDATA）

### 时钟控制
- 内部高精度、高稳定的高速 IRC（4MHz～45MHz，ISP 编程时可进行上下调整，还可以用户软件分频到
较低的频率工作，如 100KHz）
- 误差±0.3%（常温下 25℃）
- -1.38%～+1.42%温漂（全温度范围，-40℃～85℃）
- -0.88%～+1.05%温漂（温度范围，-20℃～65℃）
- 内部 32KHz 低速 IRC（为了低功耗，省去了温度补偿和电压补偿电路，误差较大）
- 外部晶振（4MHz～45MHz）和外部时钟

### 复位
- 硬件复位
  - 上电复位，实测电压值为 1.69V～1.82V。（在芯片未使能低压复位功能时有效）
  上电复位电压由一个上限电压和一个下限电压组成的电压范围，当工作电压从 5V/3.3V 向下掉到上
  电复位的下限门槛电压时，芯片处于复位状态；当电压从 0V 上升到上电复位的上限门槛电压时，
  芯片解除复位状态。
  - 复位脚复位，出厂时 P5.4 默认为 I/O 口，ISP 下载时可将 P5.4 管脚设置为复位脚（注意：当设置 P5.4
  管脚为复位脚时，复位电平为低电平）
  - 看门狗溢出复位
  - 低压检测复位，提供 4 级低压检测电压：2.0V（实测为 1.90V～2.04V）、2.4V（实测为 2.30V～2.50V）、
  2.7V（实测为 2.61V～2.82V）、3.0V（实测为 2.90V～3.13V）。
  每级低压检测电压都是由一个上限电压和一个下限电压组成的电压范围，当工作电压从 5V/3.3V 向
  下掉到低压检测的下限门槛电压时，低压检测生效；当电压从 0V 上升到低压检测的上限门槛电压
  时，低压检测生效。

- 软件复位
  - 软件方式写复位触发寄存器

### 中断
- 提供 43 个中断源：INT0（支持上升沿和下降沿中断）、INT1（支持上升沿和下降沿中断）、INT2（只支
持下降沿中断）、INT3（只支持下降沿中断）、INT4（只支持下降沿中断）、定时器 0、定时器 1、定时
器 2、定时器 3、定时器 4、串口 1、串口 2、串口 3、串口 4、ADC 模数转换、LVD 低压检测、SPI、I2C、
比较器、PCA/CCP/PWM、增强型 PWM、增强型 PWM 异常检测、所有的 I/O 中断（8 组）、LCD 驱动
中断、串口 1 的 DMA 接收和发送中断、串口 2 的 DMA 接收和发送中断、串口 3 的 DMA 接收和发送中
断、串口 4 的 DMA 接收和发送中断、SPI 的 DMA 中断、ADC 的 DMA 中断、LCD 驱动的 DMA 中断以
及存储器到存储器的 DMA 中断。
- 提供 4 级中断优先级
- 时钟停振模式下可以唤醒的中断：INT0(P3.2)、INT1(P3.3)、INT2(P3.6)、INT3(P3.7)、INT4(P3.0)、T0(P3.4)、
T1(P3.5)、T2(P1.2)、T3(P0.4)、T4(P0.6)、RXD(P3.0/P3.6/P1.6/P4.3)、RXD2(P1.0/P4.0)、RXD3(P0.0/P5.0)、
RXD4(P0.2/P5.0) 、 CCP0(P1.7/P2.3/P7.0/P3.3) 、 CCP1(P1.6/P2.4/P7.1/P3.2) 、 CCP2(P1.5/P2.5/P7.2/P3.1) 、
CCP3(P1.4/P2.6/P7.3/P3.0)、I2C_SDA(P1.4/P2.4/P3.3)、SPI_SS(P1.2/P2.2/P3.5)以及所有端口的 I/O 中断、
比较器中断、低压检测中断、掉电唤醒定时器唤醒

### 数字外设
- 5 个 16 位定时器：定时器 0、定时器 1、定时器 2、定时器 3、定时器 4，其中定时器 0 的模式 3 具有 NMI
（不可屏蔽中断）功能，定时器 0 和定时器 1 的模式 0 为 16 位自动重载模式
- 4 个高速串口：串口 1、串口 2、串口 3、串口 4，波特率时钟源最快可为 FOSC/4
- 4 组 16 位 PCA 模块：CCP0、CCP1、CCP2、CCP3，可用于捕获、高速脉冲输出，及 6/7/8/10 位的 PWM
输出
- 8 组 15 位增强型 PWM，可实现带死区的控制信号，并支持外部异常检测功能，另外还有 4 组传统的
PCA/CCP/PWM 可作 PWM
- SPI：支持主机模式和从机模式以及主机/从机自动切换
- I2C：支持主机模式和从机模式
- MDU16：硬件 16 位乘除法器（支持 32 位除以 16 位、16 位除以 16 位、16 位乘 16 位、数据移位以及数
据规格化等运算）
- I/O 口中断：所有的 I/O 均支持中断，每组 I/O 中断有独立的中断入口地址，所有的 I/O 中断可支持 4 种
中断模式：高电平中断、低电平中断、上升沿中断、下降沿中断
（本系列的 I/O 口中断可以进行掉电唤醒，且有 4 级中断优先级）
- LCD 驱动模块：支持 8080 和 6800 两种接口以及 8 位和 16 位数据宽度
- [DMA](#名词解释)：支持 SPI 移位接收数据到存储器、SPI 移位发送存储器的数据、串口 1/2/3/4 接收数据到的存储器、
串口 1/2/3/4 发送存储器的数据、ADC 自动采样数据到存储器（同时计算平均值）、LCD 驱动发送存储器
的数据、以及存储器到存储器的数据复制
- 硬件数字 ID：支持 32 字节

### 模拟外设
- 超高速 ADC，支持 12 位高精度 15 通道（通道 0～通道 14）的模数转换，速度最快能达到 800K（每秒进
行 80 万次 ADC 转换）
- ADC 的通道 15 用于测试内部 1.19V 参考信号源（芯片在出厂时，内部参考信号源已调整为 1.19V）
- 比较器，一组比较器（比较器的正端可选择 CMP+端口、CMP+_2、CMP+_3 和所有的 ADC 输入端口，
比较器的负端可选择 CMP-端口和内部 1.19V 的参考源，所以比较器可当作多路比较器进行分时复用）
- DAC：8 组增强型 PWM 定时器可当 8 路 DAC 使用、4 路 PCA 可当 4 路 DAC 使用
GPIO
- 最多可达 59 个 GPIO：P0.0~P0.7、P1.0~P1.7、P2.0~P2.7、P3.0~P3.7、P4.0~P4.4、P5.0~P5.5、P6.0~P6.7、
P7.0~P7.7
- 所有的 GPIO 均支持如下 4 种模式：准双向口模式、强推挽输出模式、开漏模式、高阻输入模式
- 除 P3.0 和 P3.1 外，其余所有 I/O 口上电后的状态均为高阻输入状态，用户在使用 I/O 口时必须先设置 I/O
口模式，另外每个 I/O 均可独立使能内部 4K 上拉电阻

## 名词解释

- DMA（Direct Memory Access，直接内存访问）是一种用于数据传输的技术，通常用于嵌入式系统和微控制器中。DMA 允许外设直接访问系统内存，而无需 CPU 的干预，从而提高数据传输效率和系统性能。

  主要特点：
  - 高效的数据传输：DMA 可以在外设和内存之间直接传输数据，减少了 CPU 的负担，使得 CPU 可以处理其他任务。
  - 降低延迟：通过减少数据传输时的 CPU 参与，DMA 可以降低系统的整体延迟。
  - 多通道支持：许多 DMA 控制器支持多个通道，可以同时处理多个数据传输任务。
  - 灵活性：DMA 支持多种数据传输模式，例如块传输、循环传输和突发传输等。

  应用场景：
  - 音频和视频数据流：在处理高带宽数据流时，DMA 可有效传输音频和视频数据。
  - 传感器数据采集：在嵌入式系统中，DMA 可用于快速采集传感器数据并存储到内存中。
  - 网络数据传输：在网络应用中，DMA 可加速数据包的接收和发送。

## 开发环境搭建

头文件和Keil的device database都可以直接从STC的烧录软件中获取。头文件导出文件到工程中，然后device导出到keil的根目录（一般文件夹名为keil）即可，如果Keil本身能给C51编程，那么就没问题。

### STM32 和 C51同时支持的Keil
1. 首先进入[Keil官方下载页面](https://www.keil.com/download/product/)，下载MDK5和C51的安装包，缺哪个下哪个，一般而言用这个芯片的人至少已经具有了其中一种环境。
2. 将这两个软件分别安装在两个目录下。
3. 把C51安装目录下的C51文件夹复制到MDK的根目录下。
4. 把C51安装目录下`UV4`里面的所有文件复制到MDK的`UV4`里面，提示重名时点击跳过这些文件。
5. 复制C51安装目录下`TOOLS.INI`里面的所有内容，粘贴到MDK的文件`TOOLS.INI`的末尾。修改下PATH为移动之后的路径
```text
...
[C51]
PATH="xxxxxxx"
...
```
之后一般问题不大了，如果软件之前就已经激活过的话，就不需要其它操作了。

## 程序
### 测试例程
创建一个`main.c`，然后在STC软件中导出头文件放到工程里面。
```c
#include <stc8.h>    // 引入STC8单片机的头文件

#define LED_PIN P55  // 将P5.5定义为LED引脚

// 初始化定时器0，用于延时
void Timer0_Init(void)
{
    TMOD |= 0x01;      // 设置定时器0为模式1（16位定时器）
    TH0 = 0xFC;        // 设置定时高字节 (此处为1ms定时)
    TL0 = 0x66;        // 设置定时低字节
    TR0 = 1;           // 启动定时器0
    ET0 = 1;           // 允许定时器0中断
    EA = 1;            // 开启总中断
}

// 延时n毫秒
void delay_ms(unsigned int ms)
{
    while(ms--)  // 每次延时1ms
    {
        TH0 = 0xFC;    // 重新加载定时器初值
        TL0 = 0x66;
        TF0 = 0;       // 清除溢出标志
        while(!TF0);   // 等待定时器溢出
    }
}

void main()
{
    Timer0_Init();     // 初始化定时器0
    P5M1 &= ~(1 << 5); // 设置P5.5为推挽输出模式
    P5M0 |= (1 << 5);

    while(1)
    {
        LED_PIN = 0;   // 点亮LED
        delay_ms(500); // 延时500毫秒
        LED_PIN = 1;   // 熄灭LED
        delay_ms(500); // 延时500毫秒
    }
}

```
